# deploy/kubernetes/overlays/aws/resources/secret-provider-classes.yaml

# --- SecretProviderClass for PostgreSQL Credentials ---
apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
  name: postgres-db-creds-spc
  namespace: postgres # Target namespace for the K8s Secret
spec:
  provider: aws
  parameters:
    objects: |
      - objectName: "atomic/POSTGRES_USER"
        objectType: "ssmparameter" # Assuming it could be an SSM parameter for username
                                   # Or "secretsmanager" if it's a distinct secret
                                   # For this example, let's assume it's a distinct secret for consistency
        objectType: "secretsmanager"
      - objectName: "atomic/POSTGRES_PASSWORD"
        objectType: "secretsmanager"
  secretObjects:
    - secretName: postgres-credentials # Name of the K8s Secret to create
      type: Opaque
      data:
        - objectName: "atomic/POSTGRES_USER" # Key in the K8s Secret will be POSTGRES_USER
          key: POSTGRES_USER
        - objectName: "atomic/POSTGRES_PASSWORD" # Key in the K8s Secret will be POSTGRES_PASSWORD
          key: POSTGRES_PASSWORD

---
# --- SecretProviderClass for MinIO Credentials ---
apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
  name: minio-creds-spc
  namespace: minio # Target namespace for the K8s Secret
spec:
  provider: aws
  parameters:
    objects: |
      - objectName: "atomic/STORAGE_ACCESS_KEY" # Name in AWS Secrets Manager
        objectType: "secretsmanager"
      - objectName: "atomic/STORAGE_SECRET_KEY" # Name in AWS Secrets Manager
        objectType: "secretsmanager"
  secretObjects:
    - secretName: minio-credentials # Name of the K8s Secret to create
      type: Opaque
      data:
        # Mapping AWS SM names to desired K8s Secret keys
        - objectName: "atomic/STORAGE_ACCESS_KEY"
          key: MINIO_ROOT_USER # Desired key in K8s Secret
        - objectName: "atomic/STORAGE_SECRET_KEY"
          key: MINIO_ROOT_PASSWORD # Desired key in K8s Secret

---
# --- SecretProviderClass for Functions Service Application Secrets ---
apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
  name: functions-app-secrets-spc
  namespace: functions # Target namespace for the K8s Secret
spec:
  provider: aws
  parameters:
    objects: |
      - objectName: "atomic/OPENAI_API_KEY"
        objectType: "secretsmanager"
      - objectName: "atomic/HASURA_GRAPHQL_ADMIN_SECRET"
        objectType: "secretsmanager"
      - objectName: "atomic/BASIC_AUTH_FUNCTIONS_ADMIN" # Changed from BASIC_AUTH_FUNCTIONS to match terraform secrets_manager.tf
        objectType: "secretsmanager"
      - objectName: "atomic/GOOGLE_CLIENT_ID_ATOMIC_WEB"
        objectType: "secretsmanager"
      - objectName: "atomic/ZOOM_CLIENT_SECRET"
        objectType: "secretsmanager"
      # Add other secrets for the 'functions' service as needed following this pattern
      # Example:
      # - objectName: "atomic/STRIPE_API_KEY"
      #   objectType: "secretsmanager"

  secretObjects:
    - secretName: functions-app-credentials # Name of the K8s Secret to create
      type: Opaque
      data:
        # These keys will be created in the K8s Secret 'functions-app-credentials'
        # The value for each key will be the content of the corresponding AWS Secret.
        - objectName: "atomic/OPENAI_API_KEY"
          key: OPENAI_API_KEY
        - objectName: "atomic/HASURA_GRAPHQL_ADMIN_SECRET"
          key: HASURA_GRAPHQL_ADMIN_SECRET
        - objectName: "atomic/BASIC_AUTH_FUNCTIONS_ADMIN"
          key: BASIC_AUTH # The functions deployment expects BASIC_AUTH
        - objectName: "atomic/GOOGLE_CLIENT_ID_ATOMIC_WEB"
          key: GOOGLE_CLIENT_ID_ATOMIC_WEB
        - objectName: "atomic/ZOOM_CLIENT_SECRET"
          key: ZOOM_CLIENT_SECRET
        # - objectName: "atomic/STRIPE_API_KEY"
        #   key: STRIPE_API_KEY

# --- Notes on Usage ---
# 1. Ensure the AWS Secrets Store CSI Driver and the AWS Secrets Manager provider are installed in your EKS cluster.
# 2. The EKS node IAM role or a service account IAM role (IRSA) associated with the provider pods
#    must have permissions to access the specified secrets in AWS Secrets Manager.
#    Example IAM policy snippet:
#    {
#        "Effect": "Allow",
#        "Action": [
#            "secretsmanager:GetSecretValue",
#            "secretsmanager:DescribeSecret"
#        ],
#        "Resource": [
#            "arn:aws:secretsmanager:<region>:<account-id>:secret:atomic/POSTGRES_USER-*",
#            "arn:aws:secretsmanager:<region>:<account-id>:secret:atomic/POSTGRES_PASSWORD-*",
#            "arn:aws:secretsmanager:<region>:<account-id>:secret:atomic/STORAGE_ACCESS_KEY-*",
#            # ... and so on for all secrets referenced
#        ]
#    }
#    (The -* wildcard is often used if secrets have auto-generated suffixes by AWS Secrets Manager).
#
# 3. Pods that need these secrets will mount them using a CSI volume:
#    volumes:
#      - name: my-secrets
#        csi:
#          driver: secrets-store.csi.k8s.io
#          readOnly: true
#          volumeAttributes:
#            secretProviderClass: "postgres-db-creds-spc" # Name of the SPC
#    And then mount the volume into containers:
#    volumeMounts:
#      - name: my-secrets
#        mountPath: "/mnt/secrets-store"
#        readOnly: true
#
# 4. If `secretObjects` is defined (as in these examples), the CSI driver will also sync
#    the secrets into a standard Kubernetes Secret. This allows pods to consume them
#    as environment variables directly using `envFrom` or `valueFrom`.
#    Example for a deployment in 'postgres' namespace:
#    envFrom:
#      - secretRef:
#          name: postgres-credentials # K8s secret created by the SPC
#
# 5. The `objectType` in the `parameters.objects` can be "secretsmanager" for AWS Secrets Manager
#    or "ssmparameter" for AWS Systems Manager Parameter Store. I've used "secretsmanager"
#    as per the context of AWS Secrets Manager. The Terraform setup in previous steps
#    created secrets in AWS Secrets Manager.
#
# 6. The `objectName` should exactly match the name of the secret in AWS Secrets Manager.
#    The Terraform setup used `${var.project_name}/${each.key}`. Assuming project_name is "atomic",
#    secrets are named like "atomic/POSTGRES_PASSWORD".
#
# 7. For the `functions` service, `BASIC_AUTH_FUNCTIONS_ADMIN` from AWS Secrets Manager is mapped to
#    the key `BASIC_AUTH` in the Kubernetes secret `functions-app-credentials`. This is because
#    the `functions` deployment likely expects an environment variable named `BASIC_AUTH`.
#    This demonstrates how `secretObjects.data.key` can be used to rename secrets for consumption
#    by applications. Similarly for MinIO credentials, `STORAGE_ACCESS_KEY` is mapped to `MINIO_ROOT_USER`.

# deploy/kubernetes/overlays/azure/resources/secret-provider-classes-azure.yaml

# --- SecretProviderClass for PostgreSQL Credentials (Azure) ---
apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
  name: postgres-db-creds-spc-azure
  namespace: postgres # Target namespace for the K8s Secret
spec:
  provider: azure
  parameters:
    usePodIdentity: "false" # Assumes Kubelet MI or Workload Identity for CSI driver
    keyvaultName: "atomic-kv" # Placeholder for your Azure Key Vault name
    tenantId: "YOUR_TENANT_ID" # Placeholder for your Azure Tenant ID
    objects:  |
      array:
        - |
          objectName: POSTGRES-USER # Name of the secret in Azure Key Vault
          objectType: secret
          # objectAlias: ALIAS_POSTGRES_USER # Optional: if you want a different filename in pod mount
        - |
          objectName: POSTGRES-PASSWORD
          objectType: secret
          # objectAlias: ALIAS_POSTGRES_PASSWORD
  secretObjects:
    - secretName: postgres-credentials-azure # Name of the K8s Secret to create
      type: Opaque
      data:
        - objectName: POSTGRES-USER # Corresponds to objectName in the 'objects' array above
          key: POSTGRES_USER      # Key in the K8s Secret
        - objectName: POSTGRES-PASSWORD
          key: POSTGRES_PASSWORD

---
# --- SecretProviderClass for MinIO Credentials (Azure) ---
# Assuming MinIO secrets (STORAGE-ACCESS-KEY, STORAGE-SECRET-KEY) are stored in Azure Key Vault
apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
  name: minio-creds-spc-azure
  namespace: minio # Target namespace for the K8s Secret
spec:
  provider: azure
  parameters:
    usePodIdentity: "false"
    keyvaultName: "atomic-kv"
    tenantId: "YOUR_TENANT_ID"
    objects:  |
      array:
        - |
          objectName: STORAGE-ACCESS-KEY # Name in Azure Key Vault (from terraform key_vault.tf)
          objectType: secret
        - |
          objectName: STORAGE-SECRET-KEY # Name in Azure Key Vault
          objectType: secret
  secretObjects:
    - secretName: minio-credentials-azure # Name of the K8s Secret to create
      type: Opaque
      data:
        # Mapping Key Vault secret names to desired K8s Secret keys
        - objectName: STORAGE-ACCESS-KEY
          key: MINIO_ROOT_USER # Desired key in K8s Secret for MinIO application
        - objectName: STORAGE-SECRET-KEY
          key: MINIO_ROOT_PASSWORD # Desired key in K8s Secret for MinIO application

---
# --- SecretProviderClass for Functions Service Application Secrets (Azure) ---
apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
  name: functions-app-secrets-spc-azure
  namespace: functions # Target namespace for the K8s Secret
spec:
  provider: azure
  parameters:
    usePodIdentity: "false"
    keyvaultName: "atomic-kv"
    tenantId: "YOUR_TENANT_ID"
    objects:  |
      array:
        - |
          objectName: OPENAI-API-KEY # Name in Azure Key Vault
          objectType: secret
        - |
          objectName: HASURA-GRAPHQL-ADMIN-SECRET # Name in Azure Key Vault
          objectType: secret
        - |
          objectName: BASIC-AUTH-FUNCTIONS-ADMIN # Name in Azure Key Vault (from terraform key_vault.tf)
          objectType: secret
        - |
          objectName: GOOGLE-CLIENT-ID-ATOMIC-WEB # Name in Azure Key Vault
          objectType: secret
        - |
          objectName: ZOOM-CLIENT-SECRET # Name in Azure Key Vault
          objectType: secret
        # Add other secrets for the 'functions' service as needed following this pattern
        # Example from terraform key_vault.tf:
        # - |
        #   objectName: API-TOKEN
        #   objectType: secret

  secretObjects:
    - secretName: functions-app-credentials-azure # Name of the K8s Secret to create
      type: Opaque
      data:
        # These keys will be created in the K8s Secret 'functions-app-credentials-azure'
        # The value for each key will be the content of the corresponding Azure Key Vault secret.
        - objectName: OPENAI-API-KEY
          key: OPENAI_API_KEY
        - objectName: HASURA-GRAPHQL-ADMIN-SECRET
          key: HASURA_GRAPHQL_ADMIN_SECRET
        - objectName: BASIC-AUTH-FUNCTIONS-ADMIN # Source from Key Vault
          key: BASIC_AUTH                         # Target key in K8s Secret, as expected by the 'functions' app
        - objectName: GOOGLE-CLIENT-ID-ATOMIC-WEB
          key: GOOGLE_CLIENT_ID_ATOMIC_WEB
        - objectName: ZOOM-CLIENT-SECRET
          key: ZOOM_CLIENT_SECRET
        # - objectName: API-TOKEN
        #   key: API_TOKEN

# --- Notes on Usage ---
# 1. Ensure the Azure Key Vault Provider for Secrets Store CSI Driver is installed in your AKS cluster.
#    This is often available as an AKS add-on.
# 2. The identity used by the driver (e.g., Kubelet Managed Identity if `usePodIdentity: "false"` and no specific
#    service account identity is configured for the provider) must have the "Key Vault Secrets User" role
#    assigned on the specified Azure Key Vault (`atomic-kv` in these examples). This was set up in `key_vault.tf`.
# 3. If using Workload Identity, `usePodIdentity: "false"` is still appropriate, and the service account
#    for the CSI driver provider pods (or pods that need direct access if driver is not syncing to K8s secrets)
#    would be annotated for Workload Identity. The Terraform `key_vault.tf` assigned role to `aks_kubelet_identity_object_id`.
#    If Workload Identity is used for the CSI driver itself, that identity needs the permissions.
# 4. Pods consume these secrets either by mounting them as volumes (pointing to the SecretProviderClass)
#    or by referencing the Kubernetes `Secret` objects (e.g., `postgres-credentials-azure`) created by `secretObjects`.
#    The latter allows using `envFrom` or `valueFrom` for environment variables.
# 5. `keyvaultName` and `tenantId` must be updated to your actual Azure Key Vault name and Tenant ID.
# 6. The `objectName` in the `objects` array must exactly match the secret name in Azure Key Vault.
#    The Terraform `key_vault.tf` used names like "POSTGRES-PASSWORD", "STORAGE-ACCESS-KEY", etc.
# 7. The `key` in `secretObjects.data` defines the key name within the generated Kubernetes Secret.
#    This allows mapping from a Key Vault secret name to a different environment variable name if needed
#    (e.g., KV "BASIC-AUTH-FUNCTIONS-ADMIN" to K8s Secret key "BASIC_AUTH").

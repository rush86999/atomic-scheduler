# deploy/kubernetes/overlays/gcp/resources/secret-provider-classes-gcp.yaml

# --- SecretProviderClass for PostgreSQL Credentials (GCP) ---
apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
  name: postgres-db-creds-spc-gcp
  namespace: postgres # Target namespace for the K8s Secret
spec:
  provider: gcp
  parameters:
    secrets: |
      - resourceName: "projects/atomic-gcp-project/secrets/POSTGRES_USER/versions/latest"
        # fileName: "POSTGRES_USER" # Optional: for file mount path
      - resourceName: "projects/atomic-gcp-project/secrets/POSTGRES_PASSWORD/versions/latest"
        # fileName: "POSTGRES_PASSWORD"
  secretObjects:
    - secretName: postgres-credentials-gcp # Name of the K8s Secret to create
      type: Opaque
      data:
        - objectName: POSTGRES_USER # This must match a name derived from resourceName or a defined objectAlias/fileName if specified in 'secrets'
                                    # For GCP provider, objectName in secretObjects.data refers to the filename if mounted,
                                    # or the base name of the secret if not using fileName/objectAlias.
                                    # Let's assume it defaults to the secret ID part of resourceName.
          key: POSTGRES_USER      # Key in the K8s Secret
        - objectName: POSTGRES_PASSWORD
          key: POSTGRES_PASSWORD

---
# --- SecretProviderClass for MinIO Credentials (GCP) ---
# Assuming MinIO secrets (STORAGE_ACCESS_KEY, STORAGE_SECRET_KEY) are stored in Google Secret Manager
apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
  name: minio-creds-spc-gcp
  namespace: minio # Target namespace for the K8s Secret
spec:
  provider: gcp
  parameters:
    secrets: |
      - resourceName: "projects/atomic-gcp-project/secrets/STORAGE_ACCESS_KEY/versions/latest"
        # fileName: "MINIO_STORAGE_ACCESS_KEY" # Using fileName to clarify mapping for secretObjects
      - resourceName: "projects/atomic-gcp-project/secrets/STORAGE_SECRET_KEY/versions/latest"
        # fileName: "MINIO_STORAGE_SECRET_KEY"

  secretObjects:
    - secretName: minio-credentials-gcp # Name of the K8s Secret to create
      type: Opaque
      data:
        # Mapping Google Secret Manager secret names to desired K8s Secret keys
        - objectName: STORAGE_ACCESS_KEY # Refers to the secret_id part of resourceName
          key: MINIO_ROOT_USER          # Desired key in K8s Secret for MinIO application
        - objectName: STORAGE_SECRET_KEY
          key: MINIO_ROOT_PASSWORD      # Desired key in K8s Secret for MinIO application

---
# --- SecretProviderClass for Functions Service Application Secrets (GCP) ---
apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
  name: functions-app-secrets-spc-gcp
  namespace: functions # Target namespace for the K8s Secret
spec:
  provider: gcp
  parameters:
    secrets: |
      - resourceName: "projects/atomic-gcp-project/secrets/OPENAI_API_KEY/versions/latest"
      - resourceName: "projects/atomic-gcp-project/secrets/HASURA_GRAPHQL_ADMIN_SECRET/versions/latest"
      - resourceName: "projects/atomic-gcp-project/secrets/BASIC_AUTH_FUNCTIONS_ADMIN/versions/latest"
        # fileName: "BASIC_AUTH" # Using fileName to map to the expected K8s Secret key via objectName
      - resourceName: "projects/atomic-gcp-project/secrets/GOOGLE_CLIENT_ID_ATOMIC_WEB/versions/latest"
      - resourceName: "projects/atomic-gcp-project/secrets/ZOOM_CLIENT_SECRET/versions/latest"
      # Example for API-TOKEN from terraform secret_manager.tf
      # - resourceName: "projects/atomic-gcp-project/secrets/API_TOKEN/versions/latest"

  secretObjects:
    - secretName: functions-app-credentials-gcp # Name of the K8s Secret to create
      type: Opaque
      data:
        - objectName: OPENAI_API_KEY
          key: OPENAI_API_KEY
        - objectName: HASURA_GRAPHQL_ADMIN_SECRET
          key: HASURA_GRAPHQL_ADMIN_SECRET
        - objectName: BASIC_AUTH_FUNCTIONS_ADMIN # Use the original Secret ID from GCP
          key: BASIC_AUTH                       # Target key in K8s Secret, as expected by the 'functions' app
        - objectName: GOOGLE_CLIENT_ID_ATOMIC_WEB
          key: GOOGLE_CLIENT_ID_ATOMIC_WEB
        - objectName: ZOOM_CLIENT_SECRET
          key: ZOOM_CLIENT_SECRET
        # - objectName: API_TOKEN
        #   key: API_TOKEN

# --- Notes on Usage ---
# 1. Ensure the Google Secret Manager provider for Secrets Store CSI Driver is installed in your GKE cluster.
#    This typically involves enabling the driver as a GKE add-on or installing it manually.
# 2. The Kubernetes Service Account (KSA) for pods that will consume these secrets (or the KSA used by the CSI driver node daemonset itself)
#    must be linked to a Google Service Account (GSA) via Workload Identity.
#    This GSA (e.g., `var.gke_secret_accessor_gsa_email` from Terraform) must have the `roles/secretmanager.secretAccessor`
#    permission on the individual secrets in Google Secret Manager. This was set up in `secret_manager.tf`.
#    The KSA needs to be annotated like:
#    annotations:
#      iam.gke.io/gcp-service-account: "your-gsa-email@your-gcp-project.iam.gserviceaccount.com"
# 3. Pods consume these secrets either by mounting them as volumes (pointing to the SecretProviderClass)
#    or by referencing the Kubernetes `Secret` objects (e.g., `postgres-credentials-gcp`) created by `secretObjects`.
#    The latter allows using `envFrom` or `valueFrom` for environment variables.
# 4. `YOUR_PROJECT_ID` in `resourceName` (e.g., `projects/atomic-gcp-project/...`) must be updated to your actual GCP Project ID.
#    I have used "atomic-gcp-project" as a placeholder.
# 5. The `SECRET_ID` part of `resourceName` (e.g., `POSTGRES_PASSWORD`) must exactly match the `secret_id`
#    of the secret in Google Secret Manager. The Terraform `secret_manager.tf` used names like "POSTGRES_PASSWORD".
# 6. In `secretObjects.data`, `objectName` refers to the `secret_id` from the `resourceName`
#    (e.g., for "projects/atomic-gcp-project/secrets/POSTGRES_PASSWORD/versions/latest", the `objectName` is "POSTGRES_PASSWORD").
#    The `key` defines the key name within the generated Kubernetes Secret. This allows mapping if needed
#    (e.g., GCP Secret "BASIC_AUTH_FUNCTIONS_ADMIN" to K8s Secret key "BASIC_AUTH").
# 7. The `fileName` parameter within the `secrets` array under `parameters` is optional. If specified, it dictates
#    the name of the file when secrets are mounted directly into a pod as files. It also dictates the `objectName`
#    to be used in `secretObjects[].data[]` when mapping to K8s secret keys. If `fileName` is not used, `objectName` in
#    `secretObjects.data` should be the `secret_id` part of the `resourceName`. I've mostly relied on the default behavior
#    where `objectName` in `secretObjects.data` refers to the `secret_id`.
#    I've removed the `fileName` examples I initially thought of adding to keep it simpler and rely on the default mapping,
#    which is usually based on the `secret_id`. If specific file names are needed for direct volume mounts, `fileName` would be used.
#    For syncing to K8s secrets, `objectName` in `secretObjects.data` should match the `secret_id`.
